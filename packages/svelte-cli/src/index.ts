#!/usr/bin/env node

import yargs from "yargs/yargs";
import { hideBin } from "yargs/helpers";
import { compile, JSONSchema } from "json-schema-to-typescript";

const bannerComment = `/* eslint-disable */
/**
 * * This file was automatically generated by @ruest/svelte-cli.
 * * DO NOT MODIFY IT BY HAND. Instead, modify the source JSON Schema file,
 * * and run @ruest/svelte-cli to regenerate this file.
 * */`;

interface RuestSchemaEntry {
  mime_types: string[];
  schema: JSONSchema;
}

function processEntry(input: RuestSchemaEntry): void {
  console.log("MIME Types:", input.mime_types);
  const title = input.schema.title ?? "Untitled";
  console.log("Schema title:", title);
  console.log("Schema:", input.schema);

  compile(input.schema, title, { additionalProperties: false, bannerComment: bannerComment }).then((ts) => {
    console.log(`Compiled for ${title}: `, ts);
  }).catch((error) => {
    console.error("Failed to compile schema to TypeScript:", error);
  });
}

const argv = yargs(hideBin(process.argv))
  .usage("usage: $0 <Ruest server address>")
  .demandCommand(1, "Ruest compatible server address is required")
  .help(true)
  .parseSync();

const serverAddress = argv._[0] as string;
const serverUrl = new URL("/.schema.json", serverAddress);

console.log("Fetching schema...");

fetch(serverUrl).then(async (response) => {
  if (!response.ok) {
    console.error(
      `Failed to fetch schema, server responded with: ${response.status} - ${response.statusText}`
    );
    process.exit(1);
  }

  const schema = await response.json();

  const schemaComponentMap = new Map<string, string>();
  var fullSchema = "";

  for (const entry of schema) {
    const rs = entry as RuestSchemaEntry;
    const title = rs.schema.title ?? "Untitled";
    
    for (const mime of rs.mime_types) {
      schemaComponentMap.set(mime, title);
    }

    processEntry(rs);
  }

  console.log("Schema component map:", schemaComponentMap);
});
