#!/usr/bin/env node

import yargs from "yargs/yargs";
import { hideBin } from "yargs/helpers";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { access, mkdir, readFile, writeFile } from "node:fs/promises";
import { join } from "node:path";
import Mustatch from "mustache";

const noModifyBannerComment = `
/**
 * * This file was automatically generated by ruest-svelte-cli.
 * * DO NOT MODIFY IT BY HAND. If you wish to update the file,
 * * run ruest-svelte-cli to get the latest schemas.
 * */`;

const canModifyBannerComment = `
/**
 * * This file was automatically generated by ruest-svelte-cli.
 * * If you modify it by hand, IT WILL NOT BE REGENERATED. If you wish to regenerate the file
 * * please remove it before rerunning ruest-svelte-cli.
 * */`;

interface RuestSchemaEntry {
  mime_types: string[];
  schema: JSONSchema;
}

async function exists(path: string) {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

async function renderTemplateFile(templateName: string, view: any): Promise<string> {
  const path = join(__dirname, "templates", templateName);
  const contents = await readFile(path, "utf-8");

  return Mustatch.render(contents, view);
}

async function writeTsFile(folder: string, fileName: string, content: string, overwrite = true) {
  const fullPath = join(folder, fileName);
  if (!overwrite) {
    if (await exists(fullPath)) {
      console.log(`File ${fullPath} already exists, skipping...`);
      return;
    }
  }

  await mkdir(folder, { recursive: true });
  const data = new Uint8Array(Buffer.from(content));
  const file = join(folder, fileName);
  await writeFile(file, data);
}

async function processEntry(input: RuestSchemaEntry, libFolder: string) {
  const title = input.schema.title ?? "Untitled";

  const ts = await compile(input.schema, title, {
    additionalProperties: false,
    bannerComment: noModifyBannerComment,
  });

  const ruestFolder = join(libFolder, "ruest");
  await writeTsFile(ruestFolder, `${title}.ts`, ts);

  const componentFolder = join(libFolder, "components");
  const componentContents = await renderTemplateFile("component.svelte.mustache", { name: title });

  await writeTsFile(componentFolder, `${title}Component.svelte`, componentContents, false);
}

async function writeErrorFiles() {
  const errorsPath = join("src", "lib", "components", "errors");
  const missingContentTypeContents = await renderTemplateFile("MissingContentType.svelte.mustache", {});
  await writeTsFile(errorsPath, "MissingContentType.svelte", missingContentTypeContents, false);

  const unknownContentTypeContents = await renderTemplateFile("UnknownContentType.svelte.mustache", {});
  await writeTsFile(errorsPath, "UnknownContentType.svelte", unknownContentTypeContents, false);
}

async function writeEnvFile(serverUrl: string) {
  const envContents = await renderTemplateFile("dotEnv.mustache", { serverUrl });

  await writeTsFile(".", ".env", envContents, false);
}

async function writeHooksFile() {
  const hooksContents = await renderTemplateFile("hooks.server.ts.mustache", { });
  await writeTsFile("src", "hooks.server.ts", hooksContents, false);
}

async function writeSvelteRouter(schemaComponentMap: Map<string, string>) {
  const svelteRouterPath = join("src", "routes", "[...path]");

  const acceptMimeTypes = Array.from(schemaComponentMap.keys()).join(", ");

  const pageTsContents = await renderTemplateFile("+page.ts.mustache", { acceptMimeTypes });
  await writeTsFile(svelteRouterPath, "+page.ts", pageTsContents, false);

  const components = Array.from(schemaComponentMap.values()).map(component => `${component}Component`);
  
  var routes = new Array<{contentType: string, component: string, logic: string}>();

  var first = true;
  for (const [contentType, component] of schemaComponentMap) {
    const logic = first ? "{#if" : "{:else if";
    first = false;
    routes.push({ contentType, component: `${component}Component`, logic });
  }

  const pageSvelteContents = await renderTemplateFile("+page.svelte.mustache", { components, routes });
  await writeTsFile(svelteRouterPath, "+page.svelte", pageSvelteContents, false);
}

async function processSchema(serverAddress: string) {
  console.log("Fetching schema...");

  const serverUrl = new URL("/.schema.json", serverAddress);

  const response = await fetch(serverUrl);

  if (!response.ok) {
    console.error(`Failed to fetch schema, server responded with: ${response.status} - ${response.statusText}`);
    process.exit(1);
  }

  const schema = await response.json();

  const schemaComponentMap = new Map<string, string>();
  const knownMimeTypes = new Set<string>();
  const libFolder = join("src", "lib");

  for (const entry of schema) {
    const rs = entry as RuestSchemaEntry;
    const title = rs.schema.title ?? "Untitled";

    for (const mime of rs.mime_types) {
      schemaComponentMap.set(mime, title);
      knownMimeTypes.add(mime);
    }

    processEntry(rs, libFolder).catch((err) => {
      console.error("Failed to process schema entry:", err);
    });
  }

  await writeErrorFiles();
  await writeEnvFile(serverAddress);
  await writeHooksFile();
  await writeSvelteRouter(schemaComponentMap);
}

const argv = yargs(hideBin(process.argv))
  .usage("usage: $0 <Ruest server address>")
  .demandCommand(1, "Ruest compatible server address is required")
  .help(true)
  .parseSync();

const serverAddress = argv._[0] as string;

processSchema(serverAddress).catch((err) => {
  console.error("Failed to process schema:", err);
});
