#!/usr/bin/env node

import yargs from "yargs/yargs";
import { hideBin } from "yargs/helpers";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { mkdir, writeFile } from 'node:fs/promises';
import { join } from "node:path";

const bannerComment = `/* eslint-disable */
/**
 * * This file was automatically generated by @ruest/svelte-cli.
 * * DO NOT MODIFY IT BY HAND. If you wish to update the file,
 * * run @ruest/svelte-cli to get the latest schemas.
 * */`;

interface RuestSchemaEntry {
  mime_types: string[];
  schema: JSONSchema;
}

async function processEntry(input: RuestSchemaEntry, libFolder: string) {
  console.log("MIME Types:", input.mime_types);
  const title = input.schema.title ?? "Untitled";
  console.log("Schema title:", title);
  console.log("Schema:", input.schema);

  const ts = await compile(input.schema, title, { additionalProperties: false, bannerComment: bannerComment })
  console.log("Generated TypeScript:", ts);
  
  const ruestFolder = join(libFolder, "ruest");
  await mkdir(ruestFolder, { recursive: true });
  const data = new Uint8Array(Buffer.from(ts));
  const file = join(ruestFolder, `${title}.ts`);
  await writeFile(file, data);

  const componentFolder = join(libFolder, "components");
  await mkdir(componentFolder, { recursive: true });
  const componentFile = join(componentFolder, `${title}.svelte`);
  const componentData = new Uint8Array(Buffer.from(
`<script lang="ts">
  import { ${title} } from '../ruest/${title}'

  export let data: ${title}
</script>`));
  await writeFile(componentFile, componentData);
}

const argv = yargs(hideBin(process.argv))
  .usage("usage: $0 <Ruest server address>")
  .demandCommand(1, "Ruest compatible server address is required")
  .help(true)
  .parseSync();

const serverAddress = argv._[0] as string;
const serverUrl = new URL("/.schema.json", serverAddress);

console.log("Fetching schema...");

fetch(serverUrl).then(async (response) => {
  if (!response.ok) {
    console.error(
      `Failed to fetch schema, server responded with: ${response.status} - ${response.statusText}`
    );
    process.exit(1);
  }

  const schema = await response.json();

  const schemaComponentMap = new Map<string, string>();
  const libFolder = join("src", "lib");

  for (const entry of schema) {
    const rs = entry as RuestSchemaEntry;
    const title = rs.schema.title ?? "Untitled";
    
    for (const mime of rs.mime_types) {
      schemaComponentMap.set(mime, title);
    }

    processEntry(rs, libFolder).catch((err) => { console.error("Failed to process schema entry:", err); });
  }

  console.log("Schema component map:", schemaComponentMap);
});
