#!/usr/bin/env node

import yargs from "yargs/yargs";
import { hideBin } from "yargs/helpers";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { access, mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { Url } from "node:url";

const noModifyBannerComment = `
/**
 * * This file was automatically generated by @ruest/svelte-cli.
 * * DO NOT MODIFY IT BY HAND. If you wish to update the file,
 * * run @ruest/svelte-cli to get the latest schemas.
 * */`;

const canModifyBannerComment = `
/**
 * * This file was automatically generated by @ruest/svelte-cli.
 * * If you modify it by hand, IT WILL NOT BE REGENERATED. If you wish to regenerate the file
 * * please remove it before rerunning @ruest/svelte-cli.
 * */`;

interface RuestSchemaEntry {
  mime_types: string[];
  schema: JSONSchema;
}

async function exists(path: string) {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

async function writeTsFile(
  folder: string,
  fileName: string,
  content: string,
  overwrite = true
) {
  const fullPath = join(folder, fileName);
  if (!overwrite) {
    if (await exists(fullPath)) {
      console.log(`File ${fullPath} already exists, skipping...`);
      return;
    }
  }

  await mkdir(folder, { recursive: true });
  const data = new Uint8Array(Buffer.from(content));
  const file = join(folder, fileName);
  await writeFile(file, data);
}

async function processEntry(input: RuestSchemaEntry, libFolder: string) {
  console.log("MIME Types:", input.mime_types);
  const title = input.schema.title ?? "Untitled";
  console.log("Schema title:", title);
  console.log("Schema:", input.schema);

  const ts = await compile(input.schema, title, {
    additionalProperties: false,
    bannerComment: noModifyBannerComment,
  });
  console.log("Generated TypeScript:", ts);

  const ruestFolder = join(libFolder, "ruest");
  await writeTsFile(ruestFolder, `${title}.ts`, ts);

  const componentFolder = join(libFolder, "components");
  const componentContents = `${canModifyBannerComment}
<script lang="ts">
  import type { ${title} } from '../ruest/${title}'

  export let data: ${title}
</script>

<h1>${title}</h1>`;

  await writeTsFile(
    componentFolder,
    `${title}Component.svelte`,
    componentContents,
    false
  );
}

async function writeErrorFiles() {
  const errorsPath = join("src", "lib", "components", "errors");
  const missingContentTypeContents = `${canModifyBannerComment}
<script lang="ts">
    interface MissingContentTypeProps {
        contentType: string
        item: any
    }
    export let data: MissingContentTypeProps
</script>

<div>
    <h1>Server error: missing content type</h1>
    <p>Content type was not sent, is this a Ruest server?</p>
    <p>Here's the raw data:</p>
    <pre>{JSON.stringify(data.item, null, 2)}</pre>
</div>`;
  await writeTsFile(errorsPath, "MissingContentType.svelte", missingContentTypeContents, false);

  const unknownContentTypeContents = `${canModifyBannerComment}
<script lang="ts">
	interface UnknownContentTypeProps {
		contentType: string;
		item: any;
	}
	export let data: UnknownContentTypeProps;
</script>

{#if import.meta.env.DEV}
	<div class="p-8">
		<h1
			class="mb-4 text-4xl font-extrabold leading-none tracking-tight text-gray-900 md:text-5xl lg:text-6xl"
		>
			Unknown Content Type
		</h1>
		<p>Unknown content type <span class="bg-slate-200">{data.contentType}</span> recieved.</p>
		<p class="pt-4">Here's the raw data:</p>
		<code class="block overflow-x-scroll whitespace-pre bg-slate-200"
			>{JSON.stringify(data.item, null, 2)}</code
		>
	</div>
{:else}
	<div class="p-8">
		<h1
			class="mb-4 text-4xl font-extrabold leading-none tracking-tight text-gray-900 md:text-5xl lg:text-6xl"
		>
			Something went wrong...
		</h1>
		<p>We're sorry for the inconvenience</p>
	</div>
{/if}`;
  await writeTsFile(errorsPath, "UnknownContentType.svelte", unknownContentTypeContents, false);
}

async function writeEnvFile(serverUrl: string) {
  const envContents = `${canModifyBannerComment}
VITE_RUEST_SERVER="${serverUrl}"`;

  await writeTsFile(".", ".env", envContents, false);
}

async function writeHooksFile() {
  const hooksContents = `${canModifyBannerComment}
import type { Handle } from '@sveltejs/kit';

export const handle: Handle = async ({ event, resolve }) => {
	return resolve(event, {
        filterSerializedResponseHeaders: (name) => name == 'content-type',
    });
};`;

  await writeTsFile("src", "hooks.server.ts", hooksContents, false);
}

async function writeSvelteRouter() {
  const pageTsPath = join("src", "routes", "[...path]");
  const pageTsContents = `${canModifyBannerComment}
import { error } from '@sveltejs/kit';
import type { PageLoad } from './$types';

export const load: PageLoad = async ({ fetch, params }) => {
	const url = new URL(params.path, import.meta.env.VITE_RUEST_SERVER ?? "http://localhost:8080")
	console.log(\`Load URL: \${url.toString()}\`);
	const res = await fetch(url);

	if (!res.ok) {
		error(res.status, res.statusText)
	}

	const item = await res.json();
	return {
		item,
		contentType: res.headers.get('content-type') ?? 'unknown',
	};
};
`;

  await writeTsFile(pageTsPath, "+page.ts", pageTsContents, false);
}

async function processSchema(serverUrl: URL) {
  console.log("Fetching schema...");

  const response = await fetch(serverUrl);

  if (!response.ok) {
    console.error(
      `Failed to fetch schema, server responded with: ${response.status} - ${response.statusText}`
    );
    process.exit(1);
  }

  const schema = await response.json();

  const schemaComponentMap = new Map<string, string>();
  const knownMimeTypes = new Set<string>();
  const libFolder = join("src", "lib");

  for (const entry of schema) {
    const rs = entry as RuestSchemaEntry;
    const title = rs.schema.title ?? "Untitled";

    for (const mime of rs.mime_types) {
      schemaComponentMap.set(mime, title);
      knownMimeTypes.add(mime);
    }

    processEntry(rs, libFolder).catch((err) => {
      console.error("Failed to process schema entry:", err);
    });
  }

  await writeErrorFiles();
  await writeEnvFile(serverUrl.toString());
  await writeHooksFile();
  await writeSvelteRouter();

  console.log("Schema component map:", schemaComponentMap);
  console.log("Known MIME Types:", knownMimeTypes);
}

const argv = yargs(hideBin(process.argv))
  .usage("usage: $0 <Ruest server address>")
  .demandCommand(1, "Ruest compatible server address is required")
  .help(true)
  .parseSync();

const serverAddress = argv._[0] as string;
const serverUrl = new URL("/.schema.json", serverAddress);

processSchema(serverUrl).catch((err) => {
  console.error("Failed to process schema:", err);
});
